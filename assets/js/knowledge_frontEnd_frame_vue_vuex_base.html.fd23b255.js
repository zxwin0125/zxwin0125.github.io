"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[6151],{3386:(n,e)=>{e.A=(n,e)=>{const t=n.__vccOpts||n;for(const[n,o]of e)t[n]=o;return t}},4205:(n,e,t)=>{t.r(e),t.d(e,{comp:()=>r,data:()=>s});var o=t(6254);const a={},r=(0,t(3386).A)(a,[["render",function(n,e){return(0,o.uX)(),(0,o.CE)("div",null,[e[0]||(e[0]=(0,o.Lk)("h2",{id:"简易的状态管理方案",tabindex:"-1"},[(0,o.Lk)("a",{class:"header-anchor",href:"#简易的状态管理方案"},[(0,o.Lk)("span",null,"简易的状态管理方案")])],-1)),(0,o.Q3)(" - 如果多个组件之间需要共享状态，使用之前的方式虽然都可以实现，但是比较麻烦，而且多个组件之间互相传值，很难跟踪到数据的变化，如果出现问题的话，很难定位问题\n- 当遇到多个组件需要共享状态的时候（典型的场景如购物车），使用之前的组件通信方式都不合适，会遇到以下的问题\n  - 多个视图依赖于同一状态\n    - 如果多层嵌套的组件依赖于同一状态，使用父子组件传值可以实现，但是非常的麻烦，而且不易管理\n  - 来自不同视图的行为需要变更统一状态\n    我们可以使用父子组件的方式获取状态\n进行修改\n或者通过事件机制来改变或者同步状态的变化\n以上这些方式非常的脆弱\n通常会导致无法维护的代码\n那为了解决这些问题\n我们可以把不同组件之间的共享状态抽取出来\n存储到一个全局对象中\n并且将来使用的时候要保证它是响应式的\n这个对象创建好之后\n我们的任何组件都可以获取或修改\n全局对象中的状态\n下面我们就来演示一下\n这种简单的可以让多个组件共享状态的方案\n我们可以把多个组件的状态\n或者整个程序的状态放到一个集中的位置存储\n并且可以检测到数据的更改\n你可能已经想到了VX\n这里我们先不使用VX\n我们先自己来进行一个简单的实现\n我们先打开vs code来演示一下\n实现好的代码\n打开零五杠EASISTOR中的STO点\nJS这个模块中我们导出了一个对象\n这个对象就是我们的store\n或者我们叫做状态仓库\n它里面有状态\n还有action\n状态是用来存储数据\naction是通过视图和用户交互的时候\n用来更改状态用的\n这里还有一个debug的属性\n他的目的是为了方便调试\n如果为true的话\n在通过action修改数据的时候会打印日志\n这是集中式的状态管理\n我们所有的状态都在store中进行管理\n并且我们store是全局唯一的对象\n任意的组件都可以导入storm模块\n使用其中的状态\n更改状态也是在该模块中实现的\n再通过特殊的手段\n还可以自己记录每次状态的变换\n我们再来看这个全局的store是如何使用的\n我们打开component a\n它里边首先需要导入store\n然后把操中的state\n也就是共享的状态存储到当前组件的shared state中\n当然当前组件还可以有自己特有的状态\n我们存储在private state中\n在视图中可以直接通过shared state username来显示数据\n当点击按钮的时候\n调用store中的action修改内部属性的值为component a\n再来看component b\n这里面代码跟component a中的是一样的\n只是调用action修改名字的时候改成了component b\n注意这里ab组件中\n都访问了store中存储的状态数据\n当前component a和component b两个组件\n共享了store中的状态\n并且和用户交互的时候\n还会更改状态中的name属性\n那下面我们打开浏览器来测试一下\n我们找到简易的状态管理的这个位置\n点击A组件的按钮\n此时name属性被改为了component\na ab组件中的name属性都发生了变化\n我们再点击B组件的按钮\n效果跟刚刚是一样的\n这里我们采用了集中式的状态管理\n使用了全局唯一的对象store来存储状态\n并且我们有一个共同的约定\n组件不允许直接更改套对象的state状态属性\n如果想要改变state\n需要调用action来改变store中的状态\n最终的结果跟view x中很类似\n我们这样约定的好处是\n能够记录所有store中发生的state的变更\n当能记录死套的变更之后\n就可以实现高级的调试功能\n例如time travel就是时光旅行\n还有历史回滚功能\n后边在使用VIVX的时候\n我们会演示好到这里\n这个简易的状态管理我们就演示完了\n它跟我们VOX的使用方式很像\n那稍后我们就开始来回顾VX "),e[1]||(e[1]=(0,o.Lk)("h2",{id:"vuex",tabindex:"-1"},[(0,o.Lk)("a",{class:"header-anchor",href:"#vuex"},[(0,o.Lk)("span",null,"Vuex")])],-1))])}]]),s=JSON.parse('{"path":"/knowledge/frontEnd/frame/vue/vuex/base.html","title":"Vuex 核心概念和基本使用","lang":"zh-CN","frontmatter":{"title":"Vuex 核心概念和基本使用","order":2,"description":"简易的状态管理方案 Vuex","head":[["meta",{"property":"og:url","content":"https://www.zxwin0125.top/knowledge/frontEnd/frame/vue/vuex/base.html"}],["meta",{"property":"og:site_name","content":"欢迎来到三金的Blog！"}],["meta",{"property":"og:title","content":"Vuex 核心概念和基本使用"}],["meta",{"property":"og:description","content":"简易的状态管理方案 Vuex"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-17T12:42:05.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-17T12:42:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vuex 核心概念和基本使用\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-17T12:42:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"三金\\",\\"url\\":\\"https://www.zxwin0125.top\\"}]}"]]},"headers":[{"level":2,"title":"简易的状态管理方案","slug":"简易的状态管理方案","link":"#简易的状态管理方案","children":[]},{"level":2,"title":"Vuex","slug":"vuex","link":"#vuex","children":[]}],"git":{"createdTime":1738990747000,"updatedTime":1739796125000,"contributors":[{"name":"zxwin0125","email":"zxwin_0125@163.com","commits":2}]},"readingTime":{"minutes":4.11,"words":1234},"filePathRelative":"knowledge/frontEnd/frame/vue/vuex/base.md","localizedDate":"2025年2月8日","excerpt":"<h2>简易的状态管理方案</h2>\\n\x3c!-- - 如果多个组件之间需要共享状态，使用之前的方式虽然都可以实现，但是比较麻烦，而且多个组件之间互相传值，很难跟踪到数据的变化，如果出现问题的话，很难定位问题\\n- 当遇到多个组件需要共享状态的时候（典型的场景如购物车），使用之前的组件通信方式都不合适，会遇到以下的问题\\n  - 多个视图依赖于同一状态\\n    - 如果多层嵌套的组件依赖于同一状态，使用父子组件传值可以实现，但是非常的麻烦，而且不易管理\\n  - 来自不同视图的行为需要变更统一状态\\n    我们可以使用父子组件的方式获取状态\\n进行修改\\n或者通过事件机制来改变或者同步状态的变化\\n以上这些方式非常的脆弱\\n通常会导致无法维护的代码\\n那为了解决这些问题\\n我们可以把不同组件之间的共享状态抽取出来\\n存储到一个全局对象中\\n并且将来使用的时候要保证它是响应式的\\n这个对象创建好之后\\n我们的任何组件都可以获取或修改\\n全局对象中的状态\\n下面我们就来演示一下\\n这种简单的可以让多个组件共享状态的方案\\n我们可以把多个组件的状态\\n或者整个程序的状态放到一个集中的位置存储\\n并且可以检测到数据的更改\\n你可能已经想到了VX\\n这里我们先不使用VX\\n我们先自己来进行一个简单的实现\\n我们先打开vs code来演示一下\\n实现好的代码\\n打开零五杠EASISTOR中的STO点\\nJS这个模块中我们导出了一个对象\\n这个对象就是我们的store\\n或者我们叫做状态仓库\\n它里面有状态\\n还有action\\n状态是用来存储数据\\naction是通过视图和用户交互的时候\\n用来更改状态用的\\n这里还有一个debug的属性\\n他的目的是为了方便调试\\n如果为true的话\\n在通过action修改数据的时候会打印日志\\n这是集中式的状态管理\\n我们所有的状态都在store中进行管理\\n并且我们store是全局唯一的对象\\n任意的组件都可以导入storm模块\\n使用其中的状态\\n更改状态也是在该模块中实现的\\n再通过特殊的手段\\n还可以自己记录每次状态的变换\\n我们再来看这个全局的store是如何使用的\\n我们打开component a\\n它里边首先需要导入store\\n然后把操中的state\\n也就是共享的状态存储到当前组件的shared state中\\n当然当前组件还可以有自己特有的状态\\n我们存储在private state中\\n在视图中可以直接通过shared state username来显示数据\\n当点击按钮的时候\\n调用store中的action修改内部属性的值为component a\\n再来看component b\\n这里面代码跟component a中的是一样的\\n只是调用action修改名字的时候改成了component b\\n注意这里ab组件中\\n都访问了store中存储的状态数据\\n当前component a和component b两个组件\\n共享了store中的状态\\n并且和用户交互的时候\\n还会更改状态中的name属性\\n那下面我们打开浏览器来测试一下\\n我们找到简易的状态管理的这个位置\\n点击A组件的按钮\\n此时name属性被改为了component\\na ab组件中的name属性都发生了变化\\n我们再点击B组件的按钮\\n效果跟刚刚是一样的\\n这里我们采用了集中式的状态管理\\n使用了全局唯一的对象store来存储状态\\n并且我们有一个共同的约定\\n组件不允许直接更改套对象的state状态属性\\n如果想要改变state\\n需要调用action来改变store中的状态\\n最终的结果跟view x中很类似\\n我们这样约定的好处是\\n能够记录所有store中发生的state的变更\\n当能记录死套的变更之后\\n就可以实现高级的调试功能\\n例如time travel就是时光旅行\\n还有历史回滚功能\\n后边在使用VIVX的时候\\n我们会演示好到这里\\n这个简易的状态管理我们就演示完了\\n它跟我们VOX的使用方式很像\\n那稍后我们就开始来回顾VX --\x3e","autoDesc":true}')}}]);