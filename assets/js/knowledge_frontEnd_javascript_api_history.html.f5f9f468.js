"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[7687],{3386:(t,i)=>{i.A=(t,i)=>{const e=t.__vccOpts||t;for(const[t,s]of i)e[t]=s;return e}},9464:(t,i,e)=>{e.r(i),e.d(i,{comp:()=>l,data:()=>r});var s=e(6254);const a={},l=(0,e(3386).A)(a,[["render",function(t,i){return(0,s.uX)(),(0,s.CE)("div",null,i[0]||(i[0]=[(0,s.Fv)('<h2 id="history" tabindex="-1"><a class="header-anchor" href="#history"><span>history</span></a></h2><blockquote><p>window.history 对象是一个只读属性</p></blockquote><ol><li>提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口</li></ol><ul><li>history.go</li><li>history.back</li><li>history.forward</li><li>history.pushState</li><li>history.replaceState</li></ul><ol start="2"><li>提供了会话历史的信息</li></ol><ul><li>history.length 会话历史中元素的数目</li><li>history.state 当前会话的状态的值（history栈顶的任意值的拷贝）</li></ul><h2 id="state" tabindex="-1"><a class="header-anchor" href="#state"><span>state</span></a></h2><blockquote><p>history 历史记录的状态信息</p></blockquote><ul><li>可以通过 history.state 查看当前历史记录的状态，返回在 history 栈顶的历史记录项的状态对象的拷贝</li><li>也可以在 popstate 事件发生后通过 event.state 查看</li><li>如果未调用 pushState 或 replaceState，state 的值将会是null</li><li>如果调用了两者，只要窗口未关闭，即便刷新页面，state 依然会保留</li></ul><h2 id="history-pushstate" tabindex="-1"><a class="header-anchor" href="#history-pushstate"><span>history.pushState</span></a></h2><ul><li>语法：<code>history.pushState(stateObj, title[, url])</code></li><li>pushState 接收3个参数 <ol><li>状态对象：一个表示state状态的能被序列化的任意值</li><li>标题</li><li>URL（可选）：定义了新的历史URL记录，默认为当前 URL</li></ol></li><li>调用 pushState 会发生 <ol><li>向 history 添加一条新的历史记录，包含 state、标题、url</li><li>修改地址栏地址为指定的 URL</li></ol></li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>以上操作都是客户端操作，并没有向服务端发送 url 请求</p></div><div class="hint-container important"><p class="hint-container-title">重要</p><p>pushState 与 <code>window.location=&#39;#foo&#39;</code> 在跳转锚点上的区别</p><ul><li>location 只有在哈希与上一个地址的哈希不同时才会创建新的历史记录，而 pushState 依然会创建</li><li>pushState 不会触发 hashchange 事件</li></ul></div><h2 id="history-replacestate" tabindex="-1"><a class="header-anchor" href="#history-replacestate"><span>history.replaceState</span></a></h2><ul><li>replaceState 与 pushState 非常相似，区别在于 replaceState 是修改当前历史记录项，而不是新建一个</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>虽然在当前页面窗口（标签）中的历史记录操作是修改而不是新建，但并不会阻止其在全局浏览器历史记录中创建一个新的历史记录项（查看浏览器历史记录）</p></div><ul><li>replaceState 的使用场景在于为了响应用户操作，更新状态对象 state 或当前历史记录的 URL</li></ul><h2 id="popstate-事件" tabindex="-1"><a class="header-anchor" href="#popstate-事件"><span>popstate 事件</span></a></h2><ul><li>当活动的历史记录项发生变化时，就会触发 popstate 事件，通过 event.state 可以访问当前历史记录的状态对象的拷贝</li><li>但是，通过调用 pushState 或 replaceState 造成的历史记录项的变更，并不会触发 popstate 事件</li><li>只有在做出浏览器动作时，才会触发该事件，例如： <ul><li>用户点击浏览器的前进后退按钮</li><li>代码中调用 history.back 、history.forward、history.go</li></ul></li><li>使用</li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">onpopstate</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vue-router-的-history-模式" tabindex="-1"><a class="header-anchor" href="#vue-router-的-history-模式"><span>vue-router 的 history 模式</span></a></h2><ul><li>vue-router 的 history 模式就是使用 pushState、replaceState、popstate 事件实现路由跳转以及监听地址变更，进而进行相应的处理（组件渲染等）</li></ul>',22)]))}]]),r=JSON.parse('{"path":"/knowledge/frontEnd/javascript/api/history.html","title":"History API","lang":"zh-CN","frontmatter":{"title":"History API","order":2,"description":"history window.history 对象是一个只读属性 提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口 history.go history.back history.forward history.pushState history.replaceState 提供了会话历史的信息 history...","head":[["meta",{"property":"og:url","content":"https://www.zxwin0125.top/knowledge/frontEnd/javascript/api/history.html"}],["meta",{"property":"og:site_name","content":"欢迎来到三金的Blog！"}],["meta",{"property":"og:title","content":"History API"}],["meta",{"property":"og:description","content":"history window.history 对象是一个只读属性 提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口 history.go history.back history.forward history.pushState history.replaceState 提供了会话历史的信息 history..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-27T05:38:26.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-27T05:38:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"History API\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-27T05:38:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"三金\\",\\"url\\":\\"https://www.zxwin0125.top\\"}]}"]]},"headers":[{"level":2,"title":"history","slug":"history","link":"#history","children":[]},{"level":2,"title":"state","slug":"state","link":"#state","children":[]},{"level":2,"title":"history.pushState","slug":"history-pushstate","link":"#history-pushstate","children":[]},{"level":2,"title":"history.replaceState","slug":"history-replacestate","link":"#history-replacestate","children":[]},{"level":2,"title":"popstate 事件","slug":"popstate-事件","link":"#popstate-事件","children":[]},{"level":2,"title":"vue-router 的 history 模式","slug":"vue-router-的-history-模式","link":"#vue-router-的-history-模式","children":[]}],"git":{"createdTime":1735277906000,"updatedTime":1735277906000,"contributors":[{"name":"zxwin0125","email":"zxwin_0125@163.com","commits":1}]},"readingTime":{"minutes":2.29,"words":688},"filePathRelative":"knowledge/frontEnd/javascript/api/history.md","localizedDate":"2024年12月27日","excerpt":"<h2>history</h2>\\n<blockquote>\\n<p>window.history 对象是一个只读属性</p>\\n</blockquote>\\n<ol>\\n<li>提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口</li>\\n</ol>","autoDesc":true}')}}]);